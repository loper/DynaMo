From 5c10471f18c5e8a28efe6e9b70d7d606c161bba8 Mon Sep 17 00:00:00 2001
From: Loper <loper.t2h@gmail.com>
Date: Wed, 15 Feb 2012 14:28:18 +0100
Subject: [PATCH 1/6] patch: otwieranie i zamykanie pliku

---
 Konfiguracja.py |   39 +++++++++++++++++++++++----------------
 README          |    2 +-
 2 files changed, 24 insertions(+), 17 deletions(-)

diff --git a/Konfiguracja.py b/Konfiguracja.py
index eb5bf5a..8da5c47 100644
--- a/Konfiguracja.py
+++ b/Konfiguracja.py
@@ -1,33 +1,40 @@
 #-*- coding: utf-8 -*-
 '''umożliwia wczytywanie ustawień do programu'''
+import logging
 
 class Konfiguracja(object):
     '''klasa Konfiguracja'''
-    
+
     __ustawienia = {}
 
     def __init__(self, plik):
         self.__otworz_plik(plik)
-    
+
     def __otworz_plik(self, konfig):
         '''otwiera plik i odczytuje z niego konfigurację'''
-        plik = open(konfig, 'r')
-        plik = plik.readlines()
-        for linia in plik:                   
-            if len(linia) <= 1:
-                continue
-            if linia[0] in ('#', '/'):
-                continue
-            linia = linia.rstrip().split("=")
-            if len(linia) != 2:
-                continue
-            self.__dodaj_do_ustawien(linia[0], linia[1])
-            
-        
+        try:
+            plik_konf = open(konfig, 'r')
+            for linia in plik_konf.readlines():
+                if len(linia) <= 1:
+                    continue
+                if linia[0] in ('#', '/'):
+                    continue
+                linia = linia.rstrip().split("=")
+                if len(linia) != 2:
+                    continue
+                self.__dodaj_do_ustawien(linia[0], linia[1])
+            del plik_konf
+        except:
+            logging.basicConfig(
+                    format = '%(message)s (in %(funcName)s at %(lineno)d)')
+            logging.error("Błąd: Nie można odnaleźć pliku konfiguracyjnego '%s'" % konfig)
+            exit(-1)
+
+
     def __dodaj_do_ustawien(self, klucz, wartosc):
         '''dodaje pozycje do słownika ustawień'''
         self.__ustawienia.update({klucz:wartosc})
-        
+
     def podaj_wartosc(self, klucz):
         try:
             return self.__ustawienia[klucz]
diff --git a/README b/README
index 0d13104..40bfcd3 100644
--- a/README
+++ b/README
@@ -1,6 +1,6 @@
 DynaMo
 
-ver. 1.0
+ver. 1.1
 _by Loper_
 
 Program umożliwia zarządzanie dynamicznymi obiektami i wywoływanie odpowiednich obiektów, co ułatwia rozbudowę programu o nową funkcjonalność. Stworzony jest w formie "wzorca", który można dostosować do własnych potrzeb i wykorzystać w swoich projektach. Zalecany jest wszędzie tam, gdzie programy tworzone są modułowo, nie tylko przez jedną osobę.
-- 
1.7.8.4


From afaa7bda9851257ac3661db33eb79121f92ecdbd Mon Sep 17 00:00:00 2001
From: Loper <loper.t2h@gmail.com>
Date: Wed, 15 Feb 2012 14:52:29 +0100
Subject: [PATCH 2/6] poprawki w readme

---
 README |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/README b/README
index 40bfcd3..6c33ac7 100644
--- a/README
+++ b/README
@@ -15,4 +15,4 @@ Funkcjonalność:
  - korekcja duplikatów z menu
  - tworzenie listy załadowanych modułów
  - włączanie programu w trybie "gadatliwym" (verbose)
-
+ - wczytywanie ustawień z pliku konfiguracyjnego
-- 
1.7.8.4


From c4eb2d32cc05f5a6b38a15be58ad164675a0c1b6 Mon Sep 17 00:00:00 2001
From: Loper <loper.t2h@gmail.com>
Date: Wed, 15 Feb 2012 20:25:19 +0100
Subject: [PATCH 3/6] poprawki w blank

---
 Makefile        |    2 +-
 README          |    6 +++++-
 moduly/blank.py |   23 ++++++++++++++++++-----
 3 files changed, 24 insertions(+), 7 deletions(-)

diff --git a/Makefile b/Makefile
index 82ee63d..03883d4 100644
--- a/Makefile
+++ b/Makefile
@@ -5,4 +5,4 @@ v:
 clean:
 	\rm -v *.pyc *.pyo moduly/*.pyc moduly/*.pyo
 patch:
-	patch -p1 < *.patch
+	@echo "aby zaktualizowac, wpisz w konsoli: patch -p1 < (nazwa_latki).patch"
diff --git a/README b/README
index 40fa06d..2c044f8 100644
--- a/README
+++ b/README
@@ -1,14 +1,18 @@
 DynaMo
 
-ver. 1.1.1
+ver. 1.2
 _by Loper_
 
+UWAGA!!!
+Wersja 1.2 nie jest kompatybilna z poprzednimi wersjami programu (zmiana silnika przetwarzania modułów). Aplikację należy uaktualnić według zaleceń z pliku 'UPDATE' lub na wiki. Poprzednie wersje nie będą dalej rozwijane i wspierane.
+
 Program umożliwia zarządzanie dynamicznymi obiektami i wywoływanie odpowiednich obiektów, co ułatwia rozbudowę programu o nową funkcjonalność. Stworzony jest w formie "wzorca", który można dostosować do własnych potrzeb i wykorzystać w swoich projektach. Zalecany jest wszędzie tam, gdzie programy tworzone są modułowo, nie tylko przez jedną osobę.
 
 Funkcjonalność:
  - wyszukiwanie i wczytywanie modułów
  - dodawanie ich do menu
  - wywoływanie ich funkcji i menu
+ - przekazywanie obiektów do modułów
  - sprawdzanie spełnienia zależności
  - sprawdzanie poprawności modułu
  - wyłączanie błędnych modułów
diff --git a/moduly/blank.py b/moduly/blank.py
index 8728112..cf615d1 100644
--- a/moduly/blank.py
+++ b/moduly/blank.py
@@ -25,20 +25,24 @@ a odczyt wartości przy pomocy funkcji 'podaj_wartosc(klucz)'.
 
 import os
 
+""" UWAGA! nazwa klasy musi być taka sama, jak nazwa pliku """
 class Nazwamodulu:
-    'klasa Nazwamodulu'
+    '''klasa Nazwamodulu'''
 
+    '''----------------- USTAWIĆ WEDŁUG UZNANIA -----------------'''
     __wersja = '0.1'
     __info = "opis"
     __pozycja_w_menu = 5
     __nazwa_w_menu = 'nazwa w menu'
     __zaleznosci = ['moduly.NiezbednyModul', 'moduly.InnyWaznyModul']
-    '''dla pustych zależności ustawić "[]"'''
+    ''' dla pustych zależności ustawić "[]"; pamiętać o "moduly." '''
+
+    '''----------------- NIE ZMIENIAĆ -----------------'''
 
     __obiekty = {}
 
     def __init__(self):
-        pass
+        self.__obiekty = {}
 
     def info(self):
         '''zwraca opis modułu'''
@@ -61,8 +65,10 @@ class Nazwamodulu:
         '''zapis przekazanych obiektów'''
         self.__obiekty = obiekty
 
-        '''dodanie pozycji do menu'''
-        self.__do_menu()
+        '''uruchomienie modułu'''
+        self.uruchom_modul()
+
+    '''----------------- TĄ CZĘŚĆ MOŻNA ZMIENIAĆ -----------------'''
 
     def menu(self, glowne_menu):
         '''pokazuje pozycje z menu'''
@@ -84,3 +90,10 @@ class Nazwamodulu:
                 print "Błędna opcja"
                 continue
         self.menu()
+
+    def uruchom_modul(self):
+        '''dodanie pozycji do menu'''
+        '''tą część można skasować, jeśli ma nie być dodawana pozycja do menu'''
+        self.__do_menu()
+
+        '''uzupelnić o własne funkcje'''
-- 
1.7.8.4


From 6e49998158aa193a75ce2826b89f7eb08e78ee41 Mon Sep 17 00:00:00 2001
From: Loper <loper.t2h@gmail.com>
Date: Wed, 15 Feb 2012 23:23:21 +0100
Subject: [PATCH 4/6] poprawiony verbose

---
 DynaMo.py |   24 +++++++++++-------------
 1 files changed, 11 insertions(+), 13 deletions(-)

diff --git a/DynaMo.py b/DynaMo.py
index 4c132e9..668e80c 100644
--- a/DynaMo.py
+++ b/DynaMo.py
@@ -10,29 +10,27 @@ from sys import argv
 import Moduly
 import Konfiguracja
 
+FORMAT = '%(message)s (in %(funcName)s at %(lineno)d)'
+
 def tryb_verbose(wlaczyc = False):
     '''włącza tryb "gadatliwy"'''
     if wlaczyc:
-        logging.basicConfig(level = logging.DEBUG)
+        logging.basicConfig(format = FORMAT, level = logging.DEBUG)
     else:
-        logging.basicConfig(level = logging.WARNING)
-
-logging.basicConfig(format = '%(message)s (in %(funcName)s at %(lineno)d)')
+        logging.basicConfig(format = FORMAT, level = logging.WARNING)
 
 KONF = Konfiguracja.Konfiguracja('ustawienia.cfg')
 
 ''' dwa sposoby włączania trybu gadatliwego:
 albo konfiguracja albo przełącznik'''
-if KONF.podaj_wartosc("verbose") == 'y':
+if KONF.podaj_wartosc("verbose"):
     tryb_verbose(True)
-else:
-    OPCJE, ARGUMENTY = getopt.getopt(argv[1:], 'v', 'verbose')
-
-    for op, arg in OPCJE:
-        if op in ('-v', '--verbose'):
-            tryb_verbose(True)
-        else:
-            tryb_verbose(False)
+
+OPCJE, ARGUMENTY = getopt.getopt(argv[1:], 'v', 'verbose')
+
+for op, arg in OPCJE:
+    if op in ('-v', '--verbose'):
+        tryb_verbose(True)
 
 os.system('clear')
 #print 20 * "\n"
-- 
1.7.8.4


From 9f21b653e52d71835bff1cbfd60b489de5a9030d Mon Sep 17 00:00:00 2001
From: Loper <loper.t2h@gmail.com>
Date: Wed, 15 Feb 2012 23:31:52 +0100
Subject: [PATCH 5/6] sprawdzanie opcji menu

---
 Menu.py |   10 +++++++---
 1 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/Menu.py b/Menu.py
index 1cc9f0f..8f92041 100644
--- a/Menu.py
+++ b/Menu.py
@@ -6,7 +6,7 @@ Opcje te odwolują się do funkcji 'menu()' dla danego obiektu
 (lista w '__zaladowane_obiekty')."""
 
 import logging
-#import os
+import os
 import sys
 
 class Menu:
@@ -55,8 +55,12 @@ class Menu:
             elif opcja == 8:
                 moduly.menu(self)
             else:
-                obj = self.__zaladowane_obiekty[opcja]
-                obj.menu(self)
+                try:
+                    obj = self.__zaladowane_obiekty[opcja]
+                    obj.menu(self)
+                except KeyError:
+                    print "Błędna opcja"
+                    continue
             self.pokaz_menu(moduly)
 
 
-- 
1.7.8.4


From d072fc667a497882b277b6815b61766507c5698b Mon Sep 17 00:00:00 2001
From: Loper <loper.t2h@gmail.com>
Date: Thu, 16 Feb 2012 21:12:44 +0100
Subject: [PATCH 6/6] dziedziczenie

---
 DynaMo.py                        |    9 ++--
 Makefile                         |    3 +-
 Menu.py                          |   19 ++++-----
 Moduly.py                        |   69 +++++++++++++++++---------------
 README                           |    2 +-
 moduly/Przyklad.py               |   50 +++++++++++++++++++++++
 moduly/{blank.py => Template.py} |   80 +++++++++++++++++++++----------------
 7 files changed, 147 insertions(+), 85 deletions(-)
 create mode 100644 moduly/Przyklad.py
 rename moduly/{blank.py => Template.py} (50%)

diff --git a/DynaMo.py b/DynaMo.py
index 668e80c..bdcfbc7 100644
--- a/DynaMo.py
+++ b/DynaMo.py
@@ -26,6 +26,8 @@ albo konfiguracja albo przełącznik'''
 if KONF.podaj_wartosc("verbose"):
     tryb_verbose(True)
 
+logging.basicConfig(format = FORMAT)
+
 OPCJE, ARGUMENTY = getopt.getopt(argv[1:], 'v', 'verbose')
 
 for op, arg in OPCJE:
@@ -33,10 +35,9 @@ for op, arg in OPCJE:
         tryb_verbose(True)
 
 os.system('clear')
-#print 20 * "\n"
-print KONF.podaj_wartosc("naglowek")
-print "wersja %s by %s" % (KONF.podaj_wartosc("wersja"),
-                           KONF.podaj_wartosc("autor"))
+print(KONF.podaj_wartosc("naglowek"))
+print("wersja %s by %s" % (KONF.podaj_wartosc("wersja"),
+                           KONF.podaj_wartosc("autor")))
 
 MODULY = Moduly.Moduly(KONF)
 logging.debug("[%s] loaded", 'Moduly')
diff --git a/Makefile b/Makefile
index 997b052..e80eb6b 100644
--- a/Makefile
+++ b/Makefile
@@ -3,7 +3,6 @@ start:
 v:
 	python DynaMo.py -v
 clean:
-	@rm -v *.pyc *.pyo moduly/*.pyc moduly/*.pyo
+	@rm *.pyc *.pyo moduly/*.pyo moduly/*.pyc
 patch:
 	@echo "aby zaktualizowac, wpisz w konsoli: patch -p1 < (nazwa_latki).patch"
-
diff --git a/Menu.py b/Menu.py
index 8f92041..815ff13 100644
--- a/Menu.py
+++ b/Menu.py
@@ -26,15 +26,15 @@ class Menu:
 
     def pokaz_menu(self, moduly):
         '''pokazuje pozycje z menu'''
-        print "\nMENU:"
+        print("\nMENU:")
         for i in self.__pozycje:
-            print "  %d: %s" % (i[0], i[1])
-        print "  0: WYJŚCIE"
+            print("  %d: %s" % (i[0], i[1]))
+        print("  0: WYJŚCIE")
         self.__wybor_menu(moduly)
 
     def pytanie_o_opcje(self):
         '''pyta o wybór z menu i zwraca opcję'''
-        opcja = raw_input('\nopcja > ')
+        opcja = input('\nopcja > ')
         try:
             opcja = int(opcja)
         except ValueError:
@@ -46,11 +46,10 @@ class Menu:
         while(1):
             opcja = self.pytanie_o_opcje()
             if opcja == None:
-                print "Błędna opcja"
+                print("Błędna opcja")
                 continue
             if opcja == 0:
                 os.system("clear")
-                #print 20 * "\n"
                 sys.exit(0)
             elif opcja == 8:
                 moduly.menu(self)
@@ -59,7 +58,7 @@ class Menu:
                     obj = self.__zaladowane_obiekty[opcja]
                     obj.menu(self)
                 except KeyError:
-                    print "Błędna opcja"
+                    print("Błędna opcja")
                     continue
             self.pokaz_menu(moduly)
 
@@ -68,7 +67,7 @@ class Menu:
         '''dodaje pozycję do menu, następnie je sortuje'''
         '''najpierw sprawdza duplikaty'''
         numer = element[0]
-        if self.__zaladowane_obiekty.has_key(numer):
+        if numer in self.__zaladowane_obiekty:
             numer = self.__znajdz_wolny()
             element = (numer, element[1])
         self.__pozycje.append(element)
@@ -96,9 +95,9 @@ class Menu:
 
     def __znajdz_wolny(self):
         '''dostępna numeracja - od 1 do 10'''
-        wolne = range(1, 9 + 1)
+        wolne = list(range(1, 9 + 1))
         for klucz in wolne:
-            if not self.__zaladowane_obiekty.has_key(klucz):
+            if klucz not in self.__zaladowane_obiekty:
                 return klucz
 
 
diff --git a/Moduly.py b/Moduly.py
index 4140371..fc4b6eb 100644
--- a/Moduly.py
+++ b/Moduly.py
@@ -4,6 +4,7 @@
 
 Modułów szuka w 'moduly/'. Wczytuje je i tworzy listę obiektów, które są
 wywoływane z poziomu menu. Dodatkowo wypisuje ich listę."""
+
 import Menu
 import copy
 import logging
@@ -41,6 +42,20 @@ class Moduly:
         '''pokaż menu'''
         self.__obiekty['menu'].pokaz_menu(self)
 
+
+    def __sprawdz_poprawnosc(self, obiekt):
+        """sprawdzanie poprawności modułu"""
+        obowiazkowe = ('podaj_zaleznosci', 'podaj_info', 'podaj_wersje',
+                     'zapisz_obiekty')
+        try:
+            for atrybut in obowiazkowe:
+                if not hasattr(obiekt, atrybut):
+                    return False
+        except AttributeError:
+            return False
+        return True
+
+
     def __wczytaj_moduly(self):
         '''dynamiczne wczytywanie i szukanie pluginow w folderze "moduly"'''
         lista_plikow = os.listdir('moduly')
@@ -50,8 +65,8 @@ class Moduly:
 
         for k in znalezione:
             i = nazwa_na_modul(k)
-            """wszystko, oprócz __init__ i blank"""
-            if i in('__init__', 'blank'):
+            """wszystko, oprócz __init__ i Template"""
+            if i in('__init__', 'Template'):
                 continue
 
             """pluginy"""
@@ -62,29 +77,19 @@ class Moduly:
             """obiekt"""
             try:
                 mod = getattr(mod, i)
-            except AttributeError, err:
+            except AttributeError as err:
                 logging.error("[%s] Error: %s", i, err)
                 continue
             obiekt = mod()
-            """sprawdzanie poprawności modułu -
-               obowiązkowe funkcje: info, wersja, zapisz_obiekty"""
-            try:
-                assert(obiekt.info != None)
-                assert(obiekt.wersja != None)
-                #assert(obiekt.menu != None)
-                assert(obiekt.zapisz_obiekty != None)
-            except AttributeError, err:
-                logging.error("[%s] Error: %s", i, err)
-                del(sys.modules[nazwa])
+            if not self.__sprawdz_poprawnosc(obiekt):
+                del sys.modules[nazwa]
+                logging.error("[%s] Error: module is incorrect", i)
                 continue
-            #"""dodawanie do menu głównego"""
-            #do_menu = obiekt.do_menu()
-            #menu.dodaj_do_menu(do_menu)
+
             self.__zaladowane_obiekty.update({nazwa: obiekt})
-            nazwa = nazwa + " (ver. %s)" % obiekt.wersja()
+            nazwa = nazwa + " (ver. %s)" % obiekt.podaj_wersje()
             self.__zaladowane_pluginy.append(nazwa)
             logging.debug("[%s] plugin loaded", i)
-        #self.__sprawdzanie_numeracji(menu)
 
 
     def podaj_zaladowane(self):
@@ -94,19 +99,19 @@ class Moduly:
     def __wypisz_zaladowane(self):
         '''wypisuje listę załadowanych i ich wersje'''
         if self.__zaladowane_pluginy == []:
-            print "brak załadowanych modułów"
+            print("brak załadowanych modułów")
         else:
-            print "\nZAŁADOWANE MODUŁY:"
+            print("\nZAŁADOWANE MODUŁY:")
             for i in self.__zaladowane_pluginy:
-                print '   - ' + i
+                print('   - ' + i)
 
     def menu(self, glowne_menu):
         '''pokazuje pozycje z menu'''
-        os.system("clear")
-        #print 20 * "\n"
-        print "MODUŁY:"
-        print "  1. Lista modułów"
-        print "  0. POWRÓT"
+        #6os.system("clear")
+        print(20 * "\n")
+        print("MODUŁY:")
+        print("  1. Lista modułów")
+        print("  0. POWRÓT")
 
         self.__wybor_menu(glowne_menu)
 
@@ -119,7 +124,7 @@ class Moduly:
             elif opcja == 1:
                 self.__wypisz_zaladowane()
             else:
-                print "Błędna opcja"
+                print("Błędna opcja")
                 continue
         self.menu(glowne_menu)
 
@@ -128,17 +133,15 @@ class Moduly:
         i ewentualnie wyłącza "złe" moduły'''
         for i in copy.copy(obiekty):
             obiekt = obiekty[i]
-            zal = obiekt.zaleznosci()
+            zal = obiekt.podaj_zaleznosci()
             for zaleznosc in zal:
                 """pustych nie sprawdzaj"""
-                if obiekt.zaleznosci() == '':
+                if zaleznosc == '':
                     continue
-                try:
-                    assert(sys.modules.get(zaleznosc) != None)
-                except AssertionError:
+                if sys.modules.get(zaleznosc) == None:
                     wadliwy_modul = str(obiekt).split('.')[1]
                     logging.error(
-                    """[%s] dependency error: \'%s\'. Module disabled""",
+                    """[%s] dependency failure: \'%s\'. Module disabled""",
                     wadliwy_modul, zaleznosc)
 
                     '''usuń skąd tylko się da'''
diff --git a/README b/README
index 2c044f8..8e9e84c 100644
--- a/README
+++ b/README
@@ -1,6 +1,6 @@
 DynaMo
 
-ver. 1.2
+ver. 1.2.1
 _by Loper_
 
 UWAGA!!!
diff --git a/moduly/Przyklad.py b/moduly/Przyklad.py
new file mode 100644
index 0000000..db12540
--- /dev/null
+++ b/moduly/Przyklad.py
@@ -0,0 +1,50 @@
+#-*- coding: utf-8 -*-
+
+from moduly.Template import Template
+import os
+
+""" UWAGA! nazwa klasy musi być taka sama, jak nazwa pliku """
+class Przyklad(Template):
+    '''klasa Przyklad'''
+
+    obiekty = {}
+
+    wersja = '1.4'
+    info = "Przykladowy moduł"
+    pozycja_w_menu = 7
+    nazwa_w_menu = 'przykład modułu'
+    zaleznosci = []
+
+    def __init__(self):
+        Template.__init__(self)
+
+    '''----------------- TĄ CZĘŚĆ NALEŻY SKOPIOWAĆ I PRZESŁONIĆ -----------------'''
+
+    def menu(self, glowne_menu):
+        '''pokazuje pozycje z menu'''
+        os.system("clear")
+        print("PRZYKŁAD:")
+        print("  0: POWRÓT")
+
+        self.wybor_menu(glowne_menu)
+
+    '''tego nie przysłaniam, bo jest takie samo, ale normalnie trzeba tu dodać własne funkcje'''
+#    def wybor_menu(self, glowne_menu):
+#        '''pyta o wybór i wywołuje daną funkcję'''
+#        while(1):
+#            opcja = glowne_menu.pytanie_o_opcje()
+#            if opcja == 0:
+#                os.system('clear')
+#                return
+#            else:
+#                print "Błędna opcja"
+#                continue
+#        self.menu()
+
+    def uruchom_modul(self):
+        '''dodanie pozycji do menu'''
+        '''tą część można skasować, jeśli ma nie być dodawana pozycja do menu'''
+        self.do_menu()
+
+        '''uzupelnić o własne funkcje'''
+        print("\n[Przykład] moja super ekstra funkcja!")
diff --git a/moduly/blank.py b/moduly/Template.py
similarity index 50%
rename from moduly/blank.py
rename to moduly/Template.py
index cf615d1..c8c4690 100644
--- a/moduly/blank.py
+++ b/moduly/Template.py
@@ -10,90 +10,100 @@ Obowiązkowe funkcje:
     - zapisz_obiekty()
 
 Obowiązkowe pola:
-    - __wersja
-    - __info
-    - __zaleznosci
+    - wersja
+    - info
     
 Jeżeli moduł ma dodawać swoją opcję do menu, obowiązkowe są:
     - __do_menu()
-    - __pozycja_w_menu
-    - __nazwa_w_menu
+    - pozycja_w_menu
+    - nazwa_w_menu
 
-Dostęp do konfiguracji jest z poziomu self.__obiekty['konfiguracja'],
+Dostęp do konfiguracji jest z poziomu self.obiekty['konfiguracja'],
 a odczyt wartości przy pomocy funkcji 'podaj_wartosc(klucz)'.
 """
 
 import os
 
 """ UWAGA! nazwa klasy musi być taka sama, jak nazwa pliku """
-class Nazwamodulu:
-    '''klasa Nazwamodulu'''
+class Template:
+    '''klasa Template'''
 
-    '''----------------- USTAWIĆ WEDŁUG UZNANIA -----------------'''
-    __wersja = '0.1'
-    __info = "opis"
-    __pozycja_w_menu = 5
-    __nazwa_w_menu = 'nazwa w menu'
-    __zaleznosci = ['moduly.NiezbednyModul', 'moduly.InnyWaznyModul']
-    ''' dla pustych zależności ustawić "[]"; pamiętać o "moduly." '''
+    '''----------------- SKOPIOWAĆ I USTAWIĆ WEDŁUG UZNANIA -----------------'''
+    wersja = '0.1'
+    #TODO: info jest nieużywane
+    info = "opis"
 
-    '''----------------- NIE ZMIENIAĆ -----------------'''
+    '''jeżeli program dodaje opcję do menu'''
+    pozycja_w_menu = 5
+    nazwa_w_menu = 'nazwa w menu'
+
+    ''' dla pustych zależności ustawić "[]" lub nie umieszczać zmiennej;
+     pamiętać o "moduly." 
+     np. zaleznosci = ['moduly.NiezbednyModul', 'moduly.InnyWaznyModul']'''
+    zaleznosci = []
 
-    __obiekty = {}
+    '''nie zmieniać, ale skopiować'''
+    obiekty = {}
+
+    '''----------------- NIE ZMIENIAĆ -----------------'''
 
     def __init__(self):
-        self.__obiekty = {}
+        self.obiekty = {}
 
-    def info(self):
+    def podaj_info(self):
         '''zwraca opis modułu'''
-        return self.__info
+        return self.info
 
-    def wersja(self):
+    def podaj_wersje(self):
         '''zwraca wersję modułu'''
-        return self.__wersja
+        return self.wersja
 
-    def zaleznosci(self):
+    def podaj_zaleznosci(self):
         '''zwraca listę zależności'''
-        return self.__zaleznosci
+        try:
+            return self.zaleznosci
+        except AttributeError:
+            return []
 
-    def __do_menu(self):
+    def do_menu(self):
         '''wysłanie listy opcji, które idą do menu'''
-        if self.__obiekty.has_key('menu'):
-            self.__obiekty['menu'].dodaj(self, (self.__pozycja_w_menu, self.__nazwa_w_menu))
+        if 'menu' in self.obiekty:
+            self.obiekty['menu'].dodaj(self, (self.pozycja_w_menu, self.nazwa_w_menu))
 
     def zapisz_obiekty(self, obiekty):
         '''zapis przekazanych obiektów'''
-        self.__obiekty = obiekty
+        self.obiekty = obiekty
 
         '''uruchomienie modułu'''
         self.uruchom_modul()
 
-    '''----------------- TĄ CZĘŚĆ MOŻNA ZMIENIAĆ -----------------'''
+    '''----------------- TĄ CZĘŚĆ NALEŻY SKOPIOWAĆ I PRZESŁONIĆ -----------------'''
 
     def menu(self, glowne_menu):
         '''pokazuje pozycje z menu'''
         os.system("clear")
-        print "NAZWA_MODULU:"
-        print "  0: POWRÓT"
+        print("NAZWA_MODULU:")
+        print("  0: POWRÓT")
 
-        self.__wybor_menu(glowne_menu)
+        self.wybor_menu(glowne_menu)
 
-    def __wybor_menu(self, glowne_menu):
+    def wybor_menu(self, glowne_menu):
         '''pyta o wybór i wywołuje daną funkcję'''
         while(1):
             opcja = glowne_menu.pytanie_o_opcje()
             if opcja == 0:
+                os.system('clear')
                 return
             elif opcja == 1:
                 pass
             else:
-                print "Błędna opcja"
+                print("Błędna opcja")
                 continue
         self.menu()
 
     def uruchom_modul(self):
         '''dodanie pozycji do menu'''
         '''tą część można skasować, jeśli ma nie być dodawana pozycja do menu'''
-        self.__do_menu()
+        self.do_menu()
 
         '''uzupelnić o własne funkcje'''
-- 
1.7.8.4

